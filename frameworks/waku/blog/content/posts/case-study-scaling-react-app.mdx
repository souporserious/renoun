---
title: Scaling a React Application from 100 to 10,000 Users
date: 2024-10-09
summary: How we optimized our React application to handle a 100x increase in users, including performance improvements and architectural changes.
category: Case Studies
tags:
  - scaling
  - performance
  - react
  - optimization
  - architecture
---

When our React application suddenly grew from 100 daily active users to 10,000+ users within six months, we faced significant performance and scalability challenges. This case study details the optimization journey and architectural decisions that enabled us to handle this growth.

## Initial Application State

**Before Scaling:**
- Single React SPA with client-side routing
- All components loaded upfront
- Basic state management with React Context
- Unoptimized images and assets
- No caching strategy
- Monolithic API calls

**Performance Metrics (100 users):**
- First Contentful Paint: 2.1s
- Largest Contentful Paint: 3.8s
- Bundle size: 1.2MB
- Time to Interactive: 4.2s

## The Growth Challenge

As user numbers increased, we experienced:
- Slow page load times (8+ seconds)
- High bounce rates (65%)
- Server overload during peak hours
- Increased customer complaints
- Rising infrastructure costs

## Optimization Strategy

### Phase 1: Bundle Optimization (Week 1-2)

**Code Splitting Implementation:**

```tsx
// Before: Single large bundle
import Dashboard from './pages/Dashboard';
import UserProfile from './pages/UserProfile';
import Reports from './pages/Reports';

// After: Lazy-loaded components
import { lazy, Suspense } from 'react';

const Dashboard = lazy(() => import('./pages/Dashboard'));
const UserProfile = lazy(() => import('./pages/UserProfile'));
const Reports = lazy(() => import('./pages/Reports'));

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/dashboard" element={
          <Suspense fallback={<PageSkeleton />}>
            <Dashboard />
          </Suspense>
        } />
        <Route path="/profile" element={
          <Suspense fallback={<PageSkeleton />}>
            <UserProfile />
          </Suspense>
        } />
        <Route path="/reports" element={
          <Suspense fallback={<PageSkeleton />}>
            <Reports />
          </Suspense>
        } />
      </Routes>
    </Router>
  );
}
```

**Bundle Analysis and Splitting:**

```javascript
// webpack-bundle-analyzer revealed large dependencies
// Before: moment.js (67KB), lodash (70KB) in main bundle

// After: Selective imports and replacements
// Replace moment.js with date-fns
import { format, parseISO } from 'date-fns';

// Replace lodash with selective imports
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';

// Tree-shaking optimization in vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          utils: ['date-fns', 'lodash'],
          charts: ['recharts', 'd3'],
        },
      },
    },
  },
});
```

### Phase 2: Image and Asset Optimization (Week 3)

**Responsive Image Implementation:**

```tsx
// Optimized image component
interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
}

function OptimizedImage({ 
  src, 
  alt, 
  width, 
  height, 
  className 
}: OptimizedImageProps) {
  const [imageSrc, setImageSrc] = useState('');
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    const img = new Image();
    img.onload = () => {
      setImageSrc(src);
      setIsLoaded(true);
    };
    img.src = src;
  }, [src]);

  return (
    <div className={`image-container ${className}`}>
      {!isLoaded && (
        <div 
          className="image-skeleton"
          style={{ width, height }}
        />
      )}
      {imageSrc && (
        <img
          src={imageSrc}
          alt={alt}
          width={width}
          height={height}
          className={isLoaded ? 'fade-in' : 'hidden'}
          loading="lazy"
        />
      )}
    </div>
  );
}

// CSS for smooth loading
.image-skeleton {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

.fade-in {
  animation: fadeIn 0.3s ease-in;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
```

**Asset Optimization Pipeline:**

```javascript
// Image optimization during build
import imagemin from 'imagemin';
import imageminWebp from 'imagemin-webp';
import imageminPngquant from 'imagemin-pngquant';
import imageminMozjpeg from 'imagemin-mozjpeg';

const optimizeImages = async () => {
  await imagemin(['src/assets/images/*.{jpg,png}'], {
    destination: 'dist/images',
    plugins: [
      imageminWebp({ quality: 75 }),
      imageminPngquant({ quality: [0.6, 0.8] }),
      imageminMozjpeg({ quality: 75 }),
    ],
  });
};
```

### Phase 3: State Management Optimization (Week 4-5)

**Migration to Zustand with Persistence:**

```typescript
// Efficient state management with Zustand
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface UserState {
  user: User | null;
  preferences: UserPreferences;
  cache: {
    dashboard: DashboardData | null;
    reports: ReportsData | null;
  };
  
  setUser: (user: User) => void;
  updatePreferences: (preferences: Partial<UserPreferences>) => void;
  setCacheData: (key: keyof UserState['cache'], data: any) => void;
  clearCache: () => void;
}

export const useUserStore = create<UserState>()(
  persist(
    immer((set) => ({
      user: null,
      preferences: {},
      cache: {
        dashboard: null,
        reports: null,
      },
      
      setUser: (user) => set((state) => {
        state.user = user;
      }),
      
      updatePreferences: (preferences) => set((state) => {
        Object.assign(state.preferences, preferences);
      }),
      
      setCacheData: (key, data) => set((state) => {
        state.cache[key] = data;
      }),
      
      clearCache: () => set((state) => {
        state.cache = { dashboard: null, reports: null };
      }),
    })),
    {
      name: 'user-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        user: state.user,
        preferences: state.preferences,
        // Don't persist cache to avoid stale data
      }),
    }
  )
);
```

**React Query for Server State:**

```tsx
// Efficient data fetching with caching
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Custom hook for dashboard data
export function useDashboardData() {
  return useQuery({
    queryKey: ['dashboard'],
    queryFn: () => apiClient.get('/dashboard'),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus: false,
  });
}

// Optimistic updates for better UX
export function useUpdateUserProfile() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData: Partial<User>) => 
      apiClient.put('/user/profile', userData),
    
    onMutate: async (newUserData) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['user'] });
      
      // Snapshot previous value
      const previousUser = queryClient.getQueryData(['user']);
      
      // Optimistically update cache
      queryClient.setQueryData(['user'], (old: User) => ({
        ...old,
        ...newUserData,
      }));
      
      return { previousUser };
    },
    
    onError: (err, newUserData, context) => {
      // Rollback on error
      queryClient.setQueryData(['user'], context?.previousUser);
    },
    
    onSettled: () => {
      // Refetch after mutation
      queryClient.invalidateQueries({ queryKey: ['user'] });
    },
  });
}
```

### Phase 4: Performance Monitoring (Week 6)

**Real User Monitoring Implementation:**

```tsx
// Performance monitoring component
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function PerformanceMonitor() {
  useEffect(() => {
    // Collect and send performance metrics
    const sendMetric = (metric: any) => {
      // Send to analytics service
      analytics.track('performance_metric', {
        name: metric.name,
        value: metric.value,
        id: metric.id,
        url: window.location.pathname,
      });
    };

    getCLS(sendMetric);
    getFID(sendMetric);
    getFCP(sendMetric);
    getLCP(sendMetric);
    getTTFB(sendMetric);
  }, []);

  return null;
}

// Usage in App component
function App() {
  return (
    <>
      <PerformanceMonitor />
      {/* Rest of app */}
    </>
  );
}
```

**Error Boundary with Monitoring:**

```tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<
  PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error to monitoring service
    console.error('Error caught by boundary:', error, errorInfo);
    
    // Send to error tracking
    analytics.track('javascript_error', {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      url: window.location.pathname,
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <button onClick={() => window.location.reload()}>
            Refresh page
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Results After Optimization

### Performance Improvements (10,000+ users):
- **First Contentful Paint**: 2.1s → 0.8s (62% improvement)
- **Largest Contentful Paint**: 3.8s → 1.4s (63% improvement)
- **Bundle size**: 1.2MB → 340KB initial + 180KB per route (72% reduction)
- **Time to Interactive**: 4.2s → 1.6s (62% improvement)

### User Experience Metrics:
- **Bounce rate**: 65% → 23% (65% improvement)
- **Session duration**: +140% increase
- **User satisfaction score**: 6.2 → 8.7 (40% improvement)

### Business Impact:
- **Conversion rate**: +85% increase
- **Infrastructure costs**: 30% reduction due to efficient caching
- **Support tickets**: 60% reduction in performance-related issues

## Architecture Changes

### Micro-Frontend Approach

For further scaling, we implemented a micro-frontend architecture:

```typescript
// Module federation configuration
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        dashboard: 'dashboard@http://localhost:3001/remoteEntry.js',
        reports: 'reports@http://localhost:3002/remoteEntry.js',
        profile: 'profile@http://localhost:3003/remoteEntry.js',
      },
    }),
  ],
};
```

### CDN and Caching Strategy

```javascript
// Service worker for aggressive caching
self.addEventListener('fetch', (event) => {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.open('images').then((cache) => {
        return cache.match(event.request).then((response) => {
          if (response) return response;
          
          return fetch(event.request).then((fetchResponse) => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});
```

## Lessons Learned

1. **Performance budgets are crucial**: Set and monitor performance budgets from day one.

2. **Incremental optimization works**: Small, consistent improvements compound over time.

3. **Measure everything**: Real user monitoring provides insights that synthetic tests miss.

4. **Cache strategically**: Smart caching can dramatically reduce server load and improve UX.

5. **User perception matters**: Perceived performance is as important as actual performance.

6. **Plan for scale early**: Architectural decisions made early have long-lasting impact.

## Conclusion

Scaling from 100 to 10,000 users required a multi-faceted approach focusing on performance optimization, smart caching, and architectural improvements. The key was measuring everything, optimizing incrementally, and always keeping the user experience at the center of our decisions. These optimizations not only handled our current scale but positioned us well for future growth.