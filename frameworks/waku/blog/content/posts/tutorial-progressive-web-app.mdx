---
title: Building a Progressive Web App with React and Workbox
date: 2024-10-05
summary: Complete guide to creating a Progressive Web App with React, including offline functionality, push notifications, and app-like experiences.
category: Tutorials
tags:
  - react
  - pwa
  - workbox
  - offline
  - notifications
---

Progressive Web Apps (PWAs) bridge the gap between web and mobile applications, offering native app-like experiences through the browser. In this comprehensive tutorial, we'll build a PWA with React that works offline, sends push notifications, and can be installed on devices.

## What We'll Build

- Offline-first React application
- Service worker for caching strategies
- Push notification system
- App installation capability
- Background sync for offline actions
- App shell architecture

## Project Setup

### Initialize React App with PWA Template

```bash
npx create-react-app pwa-tutorial --template cra-template-pwa
cd pwa-tutorial
npm install workbox-webpack-plugin workbox-window
```

### Enable PWA Features

```javascript
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Register the service worker
serviceWorkerRegistration.register({
  onSuccess: (registration) => {
    console.log('PWA registered successfully:', registration);
  },
  onUpdate: (registration) => {
    console.log('PWA update available:', registration);
    // Prompt user to reload for updates
    if (window.confirm('New version available! Reload to update?')) {
      window.location.reload();
    }
  },
});
```

## Web App Manifest Configuration

```json
{
  "short_name": "PWA Tutorial",
  "name": "Progressive Web App Tutorial",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff",
  "orientation": "portrait-primary",
  "categories": ["productivity", "utilities"],
  "description": "A comprehensive PWA tutorial application"
}
```

## Service Worker Implementation

### Custom Service Worker with Workbox

```javascript
// public/sw.js
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, cleanupOutdatedPrecaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import {
  StaleWhileRevalidate,
  CacheFirst,
  NetworkFirst,
} from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old precaches
cleanupOutdatedPrecaches();

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 3,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
);

// Background sync for offline form submissions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  const db = await openDB();
  const offlineActions = await getOfflineActions(db);
  
  for (const action of offlineActions) {
    try {
      await fetch(action.url, {
        method: action.method,
        headers: action.headers,
        body: action.body,
      });
      
      // Remove successfully synced action
      await removeOfflineAction(db, action.id);
    } catch (error) {
      console.log('Sync failed for action:', action.id);
    }
  }
}

// Push notification handling
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'New notification',
    icon: '/logo192.png',
    badge: '/logo192.png',
    actions: [
      {
        action: 'open',
        title: 'Open App',
        icon: '/logo192.png'
      },
      {
        action: 'close',
        title: 'Close',
        icon: '/logo192.png'
      }
    ],
    data: {
      url: '/'
    }
  };

  event.waitUntil(
    self.registration.showNotification('PWA Tutorial', options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'open') {
    event.waitUntil(
      clients.matchAll({ type: 'window' }).then((clients) => {
        // Check if there's already a window open
        for (const client of clients) {
          if (client.url === event.notification.data.url && 'focus' in client) {
            return client.focus();
          }
        }
        // If not, open a new window
        if (clients.openWindow) {
          return clients.openWindow(event.notification.data.url);
        }
      })
    );
  }
});
```

### Workbox Configuration

```javascript
// workbox-config.js
module.exports = {
  globDirectory: 'build/',
  globPatterns: [
    '**/*.{json,ico,html,png,txt,css,js}',
  ],
  swDest: 'build/sw.js',
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/fonts\.googleapis\.com\//,
      handler: 'StaleWhileRevalidate',
      options: {
        cacheName: 'google-fonts-stylesheets',
      },
    },
    {
      urlPattern: /^https:\/\/fonts\.gstatic\.com\//,
      handler: 'CacheFirst',
      options: {
        cacheName: 'google-fonts-webfonts',
        expiration: {
          maxEntries: 30,
          maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        },
      },
    },
  ],
};
```

## Offline Data Management

### IndexedDB Utility

```typescript
// src/utils/indexedDB.ts
interface OfflineAction {
  id: string;
  url: string;
  method: string;
  headers: Record<string, string>;
  body?: string;
  timestamp: number;
}

interface Article {
  id: string;
  title: string;
  content: string;
  author: string;
  createdAt: string;
  isOffline?: boolean;
}

class IndexedDBManager {
  private db: IDBDatabase | null = null;
  private readonly dbName = 'PWATutorialDB';
  private readonly version = 1;

  async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // Create articles store
        if (!db.objectStoreNames.contains('articles')) {
          const articlesStore = db.createObjectStore('articles', { keyPath: 'id' });
          articlesStore.createIndex('createdAt', 'createdAt');
        }

        // Create offline actions store
        if (!db.objectStoreNames.contains('offlineActions')) {
          const offlineStore = db.createObjectStore('offlineActions', { keyPath: 'id' });
          offlineStore.createIndex('timestamp', 'timestamp');
        }
      };
    });
  }

  async addArticle(article: Article): Promise<void> {
    if (!this.db) throw new Error('Database not initialized');

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['articles'], 'readwrite');
      const store = transaction.objectStore('articles');
      const request = store.add(article);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async getArticles(): Promise<Article[]> {
    if (!this.db) throw new Error('Database not initialized');

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['articles'], 'readonly');
      const store = transaction.objectStore('articles');
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async addOfflineAction(action: OfflineAction): Promise<void> {
    if (!this.db) throw new Error('Database not initialized');

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['offlineActions'], 'readwrite');
      const store = transaction.objectStore('offlineActions');
      const request = store.add(action);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async getOfflineActions(): Promise<OfflineAction[]> {
    if (!this.db) throw new Error('Database not initialized');

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['offlineActions'], 'readonly');
      const store = transaction.objectStore('offlineActions');
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async removeOfflineAction(id: string): Promise<void> {
    if (!this.db) throw new Error('Database not initialized');

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(['offlineActions'], 'readwrite');
      const store = transaction.objectStore('offlineActions');
      const request = store.delete(id);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

export const dbManager = new IndexedDBManager();
```

### Offline-First Data Hook

```typescript
// src/hooks/useOfflineData.ts
import { useState, useEffect } from 'react';
import { dbManager } from '../utils/indexedDB';

interface UseOfflineDataOptions {
  endpoint: string;
  key: string;
}

export function useOfflineData<T>({ endpoint, key }: UseOfflineDataOptions) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  useEffect(() => {
    loadData();
  }, [endpoint, isOnline]);

  const loadData = async () => {
    setLoading(true);

    try {
      if (isOnline) {
        // Try to fetch from network
        const response = await fetch(endpoint);
        if (response.ok) {
          const networkData = await response.json();
          setData(networkData);
          
          // Update local storage
          await dbManager.init();
          for (const item of networkData) {
            try {
              await dbManager.addArticle(item);
            } catch (error) {
              // Item might already exist, that's okay
            }
          }
        } else {
          throw new Error('Network request failed');
        }
      } else {
        // Load from IndexedDB
        await dbManager.init();
        const offlineData = await dbManager.getArticles();
        setData(offlineData as T[]);
      }
    } catch (error) {
      console.log('Loading from offline storage due to error:', error);
      
      // Fallback to offline data
      try {
        await dbManager.init();
        const offlineData = await dbManager.getArticles();
        setData(offlineData as T[]);
      } catch (offlineError) {
        console.error('Failed to load offline data:', offlineError);
      }
    } finally {
      setLoading(false);
    }
  };

  const addItem = async (item: T) => {
    const itemWithId = { ...item, id: Date.now().toString() };
    
    if (isOnline) {
      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(itemWithId),
        });
        
        if (response.ok) {
          setData(prev => [...prev, itemWithId]);
          return;
        }
      } catch (error) {
        console.log('Network request failed, saving offline');
      }
    }
    
    // Save offline action
    await dbManager.init();
    await dbManager.addOfflineAction({
      id: Date.now().toString(),
      url: endpoint,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(itemWithId),
      timestamp: Date.now(),
    });
    
    // Add to local data with offline flag
    const offlineItem = { ...itemWithId, isOffline: true } as T;
    setData(prev => [...prev, offlineItem]);
    
    // Register for background sync
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      const registration = await navigator.serviceWorker.ready;
      await registration.sync.register('background-sync');
    }
  };

  return { data, loading, isOnline, addItem, refetch: loadData };
}
```

## Push Notifications Implementation

### Notification Manager

```typescript
// src/utils/notificationManager.ts
class NotificationManager {
  private vapidKey = process.env.REACT_APP_VAPID_PUBLIC_KEY;

  async requestPermission(): Promise<boolean> {
    if (!('Notification' in window)) {
      console.log('This browser does not support notifications');
      return false;
    }

    if (Notification.permission === 'granted') {
      return true;
    }

    if (Notification.permission === 'denied') {
      return false;
    }

    const permission = await Notification.requestPermission();
    return permission === 'granted';
  }

  async subscribe(): Promise<PushSubscription | null> {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
      console.log('Push messaging is not supported');
      return null;
    }

    try {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.urlBase64ToUint8Array(this.vapidKey!),
      });

      // Send subscription to your server
      await this.sendSubscriptionToServer(subscription);
      
      return subscription;
    } catch (error) {
      console.error('Failed to subscribe:', error);
      return null;
    }
  }

  private async sendSubscriptionToServer(subscription: PushSubscription) {
    try {
      await fetch('/api/subscribe', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(subscription),
      });
    } catch (error) {
      console.error('Failed to send subscription to server:', error);
    }
  }

  private urlBase64ToUint8Array(base64String: string): Uint8Array {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  async showLocalNotification(title: string, options?: NotificationOptions) {
    if (!await this.requestPermission()) return;

    new Notification(title, {
      icon: '/logo192.png',
      badge: '/logo192.png',
      ...options,
    });
  }
}

export const notificationManager = new NotificationManager();
```

### Notification Component

```tsx
// src/components/NotificationSettings.tsx
import React, { useState, useEffect } from 'react';
import { notificationManager } from '../utils/notificationManager';

export const NotificationSettings: React.FC = () => {
  const [permission, setPermission] = useState(Notification.permission);
  const [subscribed, setSubscribed] = useState(false);

  useEffect(() => {
    checkSubscription();
  }, []);

  const checkSubscription = async () => {
    if ('serviceWorker' in navigator) {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.getSubscription();
      setSubscribed(!!subscription);
    }
  };

  const handleEnableNotifications = async () => {
    const granted = await notificationManager.requestPermission();
    if (granted) {
      const subscription = await notificationManager.subscribe();
      setSubscribed(!!subscription);
      setPermission('granted');
    }
  };

  const handleTestNotification = () => {
    notificationManager.showLocalNotification('Test Notification', {
      body: 'This is a test notification from your PWA!',
      actions: [
        { action: 'open', title: 'Open App' },
        { action: 'close', title: 'Close' },
      ],
    });
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-lg">
      <h2 className="text-xl font-bold mb-4">Notification Settings</h2>
      
      <div className="space-y-4">
        <div>
          <p className="text-sm text-gray-600 mb-2">
            Status: {permission === 'granted' ? '✅ Enabled' : '❌ Disabled'}
          </p>
          <p className="text-sm text-gray-600 mb-4">
            Push Subscription: {subscribed ? '✅ Active' : '❌ Inactive'}
          </p>
        </div>

        {permission !== 'granted' && (
          <button
            onClick={handleEnableNotifications}
            className="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
          >
            Enable Notifications
          </button>
        )}

        {permission === 'granted' && (
          <button
            onClick={handleTestNotification}
            className="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded"
          >
            Test Notification
          </button>
        )}
      </div>
    </div>
  );
};
```

## App Installation Features

### Install Prompt Component

```tsx
// src/components/InstallPrompt.tsx
import React, { useState, useEffect } from 'react';

interface BeforeInstallPromptEvent extends Event {
  prompt(): Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

export const InstallPrompt: React.FC = () => {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showPrompt, setShowPrompt] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);

  useEffect(() => {
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e as BeforeInstallPromptEvent);
      setShowPrompt(true);
    };

    const handleAppInstalled = () => {
      setIsInstalled(true);
      setShowPrompt(false);
      setDeferredPrompt(null);
    };

    // Check if app is already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true);
    }

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
    };
  }, []);

  const handleInstallClick = async () => {
    if (!deferredPrompt) return;

    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    
    if (outcome === 'accepted') {
      setShowPrompt(false);
    }
    
    setDeferredPrompt(null);
  };

  const handleDismiss = () => {
    setShowPrompt(false);
    setDeferredPrompt(null);
  };

  if (isInstalled || !showPrompt) {
    return null;
  }

  return (
    <div className="fixed bottom-4 left-4 right-4 bg-blue-600 text-white p-4 rounded-lg shadow-lg z-50">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="font-bold">Install PWA Tutorial</h3>
          <p className="text-sm">Add to home screen for quick access</p>
        </div>
        <div className="flex space-x-2">
          <button
            onClick={handleInstallClick}
            className="bg-white text-blue-600 px-4 py-2 rounded font-medium"
          >
            Install
          </button>
          <button
            onClick={handleDismiss}
            className="text-white px-4 py-2 rounded"
          >
            Later
          </button>
        </div>
      </div>
    </div>
  );
};
```

## Main App Component

```tsx
// src/App.tsx
import React, { useState, useEffect } from 'react';
import { useOfflineData } from './hooks/useOfflineData';
import { NotificationSettings } from './components/NotificationSettings';
import { InstallPrompt } from './components/InstallPrompt';
import './App.css';

interface Article {
  id: string;
  title: string;
  content: string;
  author: string;
  createdAt: string;
  isOffline?: boolean;
}

function App() {
  const { data: articles, loading, isOnline, addItem } = useOfflineData<Article>({
    endpoint: '/api/articles',
    key: 'articles'
  });

  const [newArticle, setNewArticle] = useState({ title: '', content: '', author: '' });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newArticle.title.trim() || !newArticle.content.trim()) return;

    await addItem({
      ...newArticle,
      id: '',
      createdAt: new Date().toISOString(),
    });

    setNewArticle({ title: '', content: '', author: '' });
  };

  return (
    <div className="min-h-screen bg-gray-100">
      <header className="bg-blue-600 text-white p-4">
        <div className="max-w-4xl mx-auto flex justify-between items-center">
          <h1 className="text-2xl font-bold">PWA Tutorial</h1>
          <div className="flex items-center space-x-4">
            <div className={`w-3 h-3 rounded-full ${isOnline ? 'bg-green-400' : 'bg-red-400'}`} />
            <span className="text-sm">{isOnline ? 'Online' : 'Offline'}</span>
          </div>
        </div>
      </header>

      <main className="max-w-4xl mx-auto p-4">
        <div className="grid gap-6 md:grid-cols-2">
          {/* Article Form */}
          <div className="bg-white p-6 rounded-lg shadow-lg">
            <h2 className="text-xl font-bold mb-4">Add New Article</h2>
            <form onSubmit={handleSubmit} className="space-y-4">
              <input
                type="text"
                placeholder="Article title"
                value={newArticle.title}
                onChange={(e) => setNewArticle({...newArticle, title: e.target.value})}
                className="w-full p-2 border border-gray-300 rounded"
                required
              />
              <input
                type="text"
                placeholder="Author name"
                value={newArticle.author}
                onChange={(e) => setNewArticle({...newArticle, author: e.target.value})}
                className="w-full p-2 border border-gray-300 rounded"
              />
              <textarea
                placeholder="Article content"
                value={newArticle.content}
                onChange={(e) => setNewArticle({...newArticle, content: e.target.value})}
                className="w-full p-2 border border-gray-300 rounded h-32"
                required
              />
              <button
                type="submit"
                className="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
              >
                Add Article {!isOnline && '(Will sync when online)'}
              </button>
            </form>
          </div>

          {/* Notification Settings */}
          <NotificationSettings />
        </div>

        {/* Articles List */}
        <div className="mt-8">
          <h2 className="text-2xl font-bold mb-4">Articles</h2>
          {loading ? (
            <div className="text-center py-8">Loading articles...</div>
          ) : (
            <div className="grid gap-4">
              {articles.map((article) => (
                <div key={article.id} className="bg-white p-6 rounded-lg shadow-lg">
                  <div className="flex justify-between items-start mb-2">
                    <h3 className="text-lg font-bold">{article.title}</h3>
                    {article.isOffline && (
                      <span className="bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded">
                        Offline
                      </span>
                    )}
                  </div>
                  <p className="text-gray-600 text-sm mb-2">By: {article.author}</p>
                  <p className="text-gray-800">{article.content}</p>
                  <p className="text-gray-500 text-xs mt-2">
                    {new Date(article.createdAt).toLocaleString()}
                  </p>
                </div>
              ))}
            </div>
          )}
        </div>
      </main>

      <InstallPrompt />
    </div>
  );
}

export default App;
```

## Performance Optimizations

### Lazy Loading and Code Splitting

```tsx
// Lazy load components
const NotificationSettings = React.lazy(() => import('./components/NotificationSettings'));
const ArticleList = React.lazy(() => import('./components/ArticleList'));

// Use Suspense for loading states
<Suspense fallback={<div>Loading...</div>}>
  <NotificationSettings />
</Suspense>
```

### Image Optimization

```tsx
// Progressive image loading component
const ProgressiveImage: React.FC<{ src: string; alt: string }> = ({ src, alt }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  
  return (
    <div className="relative">
      <img
        src={src}
        alt={alt}
        onLoad={() => setIsLoaded(true)}
        className={`transition-opacity duration-300 ${isLoaded ? 'opacity-100' : 'opacity-0'}`}
        loading="lazy"
      />
      {!isLoaded && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
    </div>
  );
};
```

## Testing PWA Features

### Lighthouse PWA Audit

Run Lighthouse to test PWA compliance:

```bash
# Install Lighthouse CLI
npm install -g lighthouse

# Run PWA audit
lighthouse http://localhost:3000 --only-categories=pwa --output=html --output-path=./pwa-audit.html
```

### Manual Testing Checklist

1. **Offline functionality**: Disconnect network and test app
2. **Installation**: Test install prompt on various devices
3. **Notifications**: Test push notification delivery
4. **Performance**: Check load times and responsiveness
5. **Cross-platform**: Test on different browsers and devices

## Deployment Considerations

### HTTPS Requirement

PWAs require HTTPS in production:

```javascript
// Express server with HTTPS
const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('path/to/private-key.pem'),
  cert: fs.readFileSync('path/to/certificate.pem')
};

https.createServer(options, app).listen(443);
```

### Service Worker Updates

Handle service worker updates gracefully:

```javascript
// Update notification
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    window.location.reload();
  });
}
```

## Conclusion

You've successfully built a comprehensive Progressive Web App with React! This PWA includes offline functionality, push notifications, installability, and all the features users expect from modern web applications. The app provides a native-like experience while maintaining the reach and accessibility of the web.

Key takeaways:
- PWAs bridge the gap between web and native apps
- Service workers enable powerful offline capabilities
- IndexedDB provides robust local data storage
- Push notifications increase user engagement
- Proper caching strategies improve performance dramatically

Your PWA is now ready for production deployment and can provide an excellent user experience across all devices and network conditions.