export const metadata = {
  title: 'MDX',
  description: 'Using MDX with renoun.',
}

This guide will help you understand how to use MDX with renoun.

## What is MDX?

[MDX](https://mdxjs.com/) is a format that allows you to write JSX directly within Markdown documents. This lets you embed React components and JSX elements inside your Markdown files, creating interactive and dynamic content. MDX works seamlessly with renoun, making it a powerful tool for your documentation needs.

## `MDX` component

The easiest way to get started using MDX with renoun is with the `MDX` component:

```tsx
import { MDX } from 'renoun'

const content = `
# Hello, world!

This is an MDX file.
`

export default function Page() {
  return <MDX>{content}</MDX>
}
```

In this example, the `MDX` component renders a string of MDX content. It parses the MDX and converts it into React components that can be rendered in your application.

## MDX with Next.js

If you're working with Next.js, configuring MDX with renoun is straightforward. We have a dedicated guide that walks you through the process of setting it up with your Next.js project.

To learn how to configure MDX with Next.js, check out the [Next.js Guide](/guides/next).

## Pre-configured Plugins

The `@renoun/mdx` package includes pre-configured plugins for both [remark](https://remark.js.org/) and [rehype](https://unifiedjs.com/), which are part the MDX process that parses and transforms MDX content.

This package is automatically installed with renoun and can be imported directly from the `renoun` package. You can import the respective plugins and add them to your MDX configuration to extend the functionality of your MDX content:

```ts
import { remarkPlugins, rehypePlugins } from 'renoun'
```

The following is a list of the plugins and their effects:

### Community Plugins

#### [`remark-gfm`](https://www.npmjs.com/package/remark-gfm)

Adds support for GitHub Flavored Markdown (GFM) to MDX.

- Enables strikethrough, tables, task lists, and URLs directly in MDX.
- Enhances the readability and functionality of markdown content.

#### [`remark-smartypants`](https://www.npmjs.com/package/remark-smartypants)

Transforms punctuation in MDX to typographically correct symbols using [SmartyPants](https://daringfireball.net/projects/smartypants/).

- Straight quotes (`"` and `'`) into "curly" quote HTML entities
- Dashes (`--` and `---`) into en- (--) and em-dash (---) entities
- Three consecutive dots (`...`) into an ellipsis entity ...

#### [`rehype-unwrap-images`](https://www.npmjs.com/package/rehype-unwrap-images)

Ensures that images are not wrapped in paragraph tags.

### renoun plugins

In addition to the community plugins listed above, renoun adds specific custom plugins to further extend the capabilities of MDX content.

#### remark `add-front-matter`

Extracts YAML front matter into a `frontMatter` export and removes it from the rendered content. This makes the metadata availab
le at build time without relying on additional remark plugins.

Front matter is also exposed on the `vfile.data.frontMatter` property during compilation, so custom remark plugins can reuse th
e parsed metadata without re-parsing the source document.

```mdx
---
title: Hello, world!
---

# Hello, world!
```

```tsx allowErrors showErrors={false}
import Page, { frontMatter } from './hello-world.mdx'

export default function Example() {
  return (
    <>
      <h1>{frontMatter.title}</h1>
      <Page />
    </>
  )
}
```

#### remark `add-headings`

Adds an `id` to all headings and exports a `headings` variable.

You can customize the exported `headings` by exporting a `getHeadings` function from your MDX file. The function receives the auto-generated `headings` and should return the array you want to expose.

```mdx
export function getHeadings(headings) {
  return [
    ...headings,
    {
      id: 'custom-section',
      level: 2,
      text: 'Custom section',
      children: 'Custom section',
    },
  ]
}

# Hello World
```

<Note>

Exporting `headings` directly is not supported. If you need to override headings, export a `getHeadings(headings)` function as shown above.

</Note>

If you're validating or typing the exported `headings` with a schema library, see the [Zod Guide](/guides/zod) and [Valibot Guide](/guides/valibot) for concrete examples of manually typing the `headings` export in your schema.

##### `Heading` component

This plugin also rewrites markdown headings (`#`, `##`, etc.) to render through a `Heading` MDX component. If you do nothing, a built-in default is used:

- **Tag**: renders the proper heading tag (`h1`-`h6`) passed as `Tag`
- **id**: assigns the generated slug as the element id
- **anchor**: wraps the children in an anchor element pointing to `#<id>`

You can override this by supplying your own `Heading` component via your MDX components provider. For example:

```tsx path="examples/docs/mdx-components.tsx"
import type { MDXComponents } from 'renoun'

export function useMDXComponents() {
  return {
    Heading: ({ Tag, id, children, ...rest }) => {
      return (
        <Tag id={id} {...rest}>
          <a href={`#${id}`} className="not-prose">
            {children}
          </a>
        </Tag>
      )
    },
  } satisfies MDXComponents
}
```

##### Security considerations

This plugin is designed for trusted MDX sources.

`getHeadings` is executed as JavaScript at build/render time, so only use it with content from trusted authors. It can access your environment and perform arbitrary actions.

All URLs in links and images are restricted to `http` and `https` schemes to prevent injection of `javascript:` or other unsafe protocols.

If you need to support untrusted MDX, run the compiled output through an HTML sanitizer such as [rehype-sanitize](https://www.npmjs.com/package/rehype-sanitize) before rendering.

#### remark `remove-immediate-paragraphs`

Removes paragraph elements added around immediate element and component children.

For example, when using elements like `div`, this will remove the paragraph element added around the text content:

```mdx
<div>
  An example of using a longer sentence in an element that when formatted by
  tools like Prettier will be moved to a new line.
</div>
```

If you'd like MDX to still wrap the text contents in a paragraph element, you can use a line break before and after the content like so:

```mdx
<div>

By adding a line break before and after the content, MDX will now wrap this text in a paragraph element.

</div>
```

#### remark `transform-jsdoc-inline-tags`

Rewrites JSDoc/TSDoc inline tags that appear inside headings and paragraphs so they render as normal links or inline code instead of verbatim tag text.

- `{@link}`, `{@linkplain}`, `{@linkcode}`, and `{@tutorial}` become `link` nodes. Labels can be provided with a pipe (`{@link Foo#bar|the bar member}`) or a space (`{@link Foo#bar the bar member}`). `linkcode` wraps the label in inline code.
- `{@code ...}` becomes inline code; `{@literal ...}` keeps the raw text without escaping.
- Unknown inline tags remain unchanged, and HTML-only runs are left as-is to avoid breaking embedded markup.

```mdx
See {@link Foo#bar|the bar member}, {@linkcode utils.call|utils.call()}, and {@code value}.
```

Renders as normal links and inline code in the compiled MDX output, making it useful for bringing JSDoc/TSDoc inline tags into user-facing documentation.

#### remark `transform-relative-links`

Reformats all relative links that use ordered numbers and extensions. For example, `./01.introduction.mdx` will be transformed to `./introduction`.

#### rehype `add-code-block`

Parses the meta string from code fences as props and replaces the parent `pre` element with a `CodeBlock` element.

<Note>

A `CodeBlock` is required to be passed as a component to the MDX renderer.

</Note>

To configure the `CodeBlock` component, either configure the `providerImportSource` in your MDX configuration which will configure the default `CodeBlock` component:

```tsx path="next.config.ts"
import createMDXPlugin from '@next/mdx'
import addCodeBlock from '@renoun/mdx/rehype/add-code-block'

const withMDX = createMDXPlugin({
  options: {
    providerImportSource: 'renoun/mdx/components',
    rehypePlugins: [addCodeBlock],
  },
})
```

Or import and pass `CodeBlock` as a component to the MDX component:

```tsx
import { CodeBlock } from 'renoun'
import GettingStarted from './docs/getting-started.mdx'

export default function Page() {
  return <GettingStarted components={{ CodeBlock }} />
}
```

#### rehype `add-reading-time`

Exports an estimated reading time for MDX content as a `readingTime` value. It uses `Intl.Segmenter` for accurate, locale-aware word segmentation, `Intl.NumberFormat` for formatting the reading time, can optionally include code blocks, and accounts for images.

<Note>

`readingTime` is exported for MDX files only (not plain Markdown). When using the default `MDX` component from `renoun`, this plugin is included automatically. If you override `rehypePlugins`, re-add it to keep the export.

</Note>

Consuming the exported `readingTime` from an MDX file:

```tsx allowErrors showErrors={false}
import GettingStarted, { readingTime } from './docs/getting-started.mdx'

export default function Page() {
  return (
    <>
      <p>{readingTime} min read</p>
      <GettingStarted />
    </>
  )
}
```

## Applying plugins

By default, the `MDX` component configures both the remark and rehype plugins from `@renoun/mdx`. You can import and apply individual plugins to the `MDX` component or any other MDX configuration in your application.

We'll use the example from before and add the `@renoun/mdx/rehype/add-code-block` plugin to the `MDX` component:

```tsx
import { MDX } from 'renoun'
import addCodeBlock from '@renoun/mdx/rehype/add-code-block'

const content = `
# Hello, world!

This is an MDX file.
`

export default function Page() {
  return <MDX rehypePlugins={[addCodeBlock]}>{content}</MDX>
}
```

Note, by overriding the `rehypePlugins` it will remove the default `@renoun/mdx` rehype plugins. If you want to keep the default plugins, you can import and apply them to the `MDX` component and add your own additional plugins:

```tsx allowErrors="2307"
import { MDX, rehypePlugins, remarkPlugins } from 'renoun'
import remarkGithub from 'remark-github'

const content = `
---
title: Hello, world!
---

# Hello, world!

This is an MDX file.
`

export default function Page() {
  return (
    <MDX
      remarkPlugins={[
        ...remarkPlugins,
        [remarkGithub, { repository: 'souporserious/renoun' }],
      ]}
      rehypePlugins={rehypePlugins}
    >
      {content}
    </MDX>
  )
}
```

<Note>

The `add-front-matter` plugin is included in `remarkPlugins` and will continue to run as long as you spread the defaults. If yo
u replace the array entirely, re-add the plugin so that `frontMatter` exports stay in sync with your Markdown and MDX files.

</Note>

## Front matter utilities

When renoun reads Markdown or MDX files from the file system it automatically removes any YAML front matter from the rendered
content and makes the metadata available as both a `frontMatter` export and a helper on the file instance. This keeps the
rendered content clean while still giving you access to the document metadata when you need it. The helper first looks for an
exported `frontMatter` value—such as the one provided by the `add-front-matter` plugin—and falls back to parsing the raw file
when a module export is not available.

```ts
import { MDXFile } from 'renoun'

const doc = new MDXFile({ path: 'docs/getting-started.mdx' })
const frontMatter = await doc.getFrontMatter()

console.log(frontMatter?.title) // → "MDX"
```

Front matter is also exported from Markdown and MDX modules, so you can import it directly alongside your content:

```tsx allowErrors showErrors={false}
import GettingStarted, { frontMatter } from './docs/getting-started.mdx'

export default function Page() {
  return (
    <>
      <h1>{frontMatter?.title}</h1>
      <GettingStarted />
    </>
  )
}
```

## Conclusion

MDX is a powerful tool that can be used to create interactive and dynamic content in your documentation. By using the `MDX` component and custom plugins, you can easily render MDX content in your components and extend the functionality of the MDX rendering process.
